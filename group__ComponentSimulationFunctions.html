<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Hopsan: ComponentSimulationFunctions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="hopsan.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Hopsan
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('group__ComponentSimulationFunctions.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">ComponentSimulationFunctions<div class="ingroups"><a class="el" href="group__ComponentAuthorFunctions.html">ComponentAuthorFunctions</a></div></div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga42bf72b453e0208c678b2c34bb0dcb40" id="r_ga42bf72b453e0208c678b2c34bb0dcb40"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga42bf72b453e0208c678b2c34bb0dcb40">readNode</a> (const size_t idx) const</td></tr>
<tr class="memdesc:ga42bf72b453e0208c678b2c34bb0dcb40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a value from the connected node.  <br /></td></tr>
<tr class="separator:ga42bf72b453e0208c678b2c34bb0dcb40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga069fa4111f0bd1baf83b86c9a766c00f" id="r_ga069fa4111f0bd1baf83b86c9a766c00f"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga069fa4111f0bd1baf83b86c9a766c00f">readNode</a> (const size_t idx, const size_t subPortIdx) const</td></tr>
<tr class="memdesc:ga069fa4111f0bd1baf83b86c9a766c00f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a value from the connected node.  <br /></td></tr>
<tr class="separator:ga069fa4111f0bd1baf83b86c9a766c00f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e3cf2c419e0f82cba4e8881be0986e1" id="r_ga3e3cf2c419e0f82cba4e8881be0986e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3e3cf2c419e0f82cba4e8881be0986e1">writeNode</a> (const size_t idx, const double value)</td></tr>
<tr class="memdesc:ga3e3cf2c419e0f82cba4e8881be0986e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a value to the connected node.  <br /></td></tr>
<tr class="separator:ga3e3cf2c419e0f82cba4e8881be0986e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89bcd188cf935b03ccdc26e5170ab3bc" id="r_ga89bcd188cf935b03ccdc26e5170ab3bc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga89bcd188cf935b03ccdc26e5170ab3bc">writeNode</a> (const size_t idx, const double value, const size_t subPortIdx)</td></tr>
<tr class="memdesc:ga89bcd188cf935b03ccdc26e5170ab3bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a value to the connected node.  <br /></td></tr>
<tr class="separator:ga89bcd188cf935b03ccdc26e5170ab3bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4160d172bac363b50a6a0123d18f128" id="r_gab4160d172bac363b50a6a0123d18f128"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab4160d172bac363b50a6a0123d18f128">readNode</a> (const size_t idx, const size_t subPortIdx) const</td></tr>
<tr class="memdesc:gab4160d172bac363b50a6a0123d18f128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a value from the connected node.  <br /></td></tr>
<tr class="separator:gab4160d172bac363b50a6a0123d18f128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac478c4f77b1aa1dcc7201693d80f128f" id="r_gac478c4f77b1aa1dcc7201693d80f128f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac478c4f77b1aa1dcc7201693d80f128f">writeNode</a> (const size_t idx, const double value, const size_t subPortIdx)</td></tr>
<tr class="memdesc:gac478c4f77b1aa1dcc7201693d80f128f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a value to the connected node.  <br /></td></tr>
<tr class="separator:gac478c4f77b1aa1dcc7201693d80f128f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25a40b6614565f755233080a384c35f1" id="r_ga25a40b6614565f755233080a384c35f1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga25a40b6614565f755233080a384c35f1">initialize</a> ()</td></tr>
<tr class="memdesc:ga25a40b6614565f755233080a384c35f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The initialize function must be overloaded in each component, it is used to initialize the component just before simulation begins.  <br /></td></tr>
<tr class="separator:ga25a40b6614565f755233080a384c35f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa63c51fa3173cbaf9d5352ed24f5f706" id="r_gaa63c51fa3173cbaf9d5352ed24f5f706"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa63c51fa3173cbaf9d5352ed24f5f706">simulateOneTimestep</a> ()</td></tr>
<tr class="memdesc:gaa63c51fa3173cbaf9d5352ed24f5f706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simulates one time step. This component must be overloaded en each component.  <br /></td></tr>
<tr class="separator:gaa63c51fa3173cbaf9d5352ed24f5f706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32d626626eee0bc4ade146973f6abb1c" id="r_ga32d626626eee0bc4ade146973f6abb1c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga32d626626eee0bc4ade146973f6abb1c">finalize</a> ()</td></tr>
<tr class="memdesc:ga32d626626eee0bc4ade146973f6abb1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional function that is called after every simulation, can be used to clean up memory allocation made in initialize.  <br /></td></tr>
<tr class="separator:ga32d626626eee0bc4ade146973f6abb1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbbc53679a2e6738e4a1a9a35d654128" id="r_gacbbc53679a2e6738e4a1a9a35d654128"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gacbbc53679a2e6738e4a1a9a35d654128">stopSimulation</a> (const <a class="el" href="classhopsan_1_1HString.html">HString</a> &amp;rReason=&quot;&quot;)</td></tr>
<tr class="memdesc:gacbbc53679a2e6738e4a1a9a35d654128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminate/stop a running initialization or simulation.  <br /></td></tr>
<tr class="separator:gacbbc53679a2e6738e4a1a9a35d654128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacbc55de899a64164d8deec608ed649e" id="r_gaacbc55de899a64164d8deec608ed649e"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaacbc55de899a64164d8deec608ed649e">getSafeNodeDataPtr</a> (<a class="el" href="classhopsan_1_1Port.html">Port</a> *pPort, const int dataId)</td></tr>
<tr class="memdesc:gaacbc55de899a64164d8deec608ed649e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the node data variable, (<a class="el" href="classhopsan_1_1Port.html">Port</a> pointer version)  <br /></td></tr>
<tr class="separator:gaacbc55de899a64164d8deec608ed649e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga216152a14db9fbf42d51bc96359de445" id="r_ga216152a14db9fbf42d51bc96359de445"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga216152a14db9fbf42d51bc96359de445">getSafeNodeDataPtr</a> (const <a class="el" href="classhopsan_1_1HString.html">HString</a> &amp;rPortName, const int dataId)</td></tr>
<tr class="memdesc:ga216152a14db9fbf42d51bc96359de445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the node data variable, (<a class="el" href="classhopsan_1_1Port.html">Port</a> name version)  <br /></td></tr>
<tr class="separator:ga216152a14db9fbf42d51bc96359de445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6f63293b243b44a847868f34cb4abe2" id="r_gac6f63293b243b44a847868f34cb4abe2"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac6f63293b243b44a847868f34cb4abe2">getSafeMultiPortNodeDataPtr</a> (<a class="el" href="classhopsan_1_1Port.html">Port</a> *pPort, const size_t portIdx, const int dataId)</td></tr>
<tr class="memdesc:gac6f63293b243b44a847868f34cb4abe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to node data in a subport in a multiport.  <br /></td></tr>
<tr class="separator:gac6f63293b243b44a847868f34cb4abe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada1ad2953a2b1f509933ae743ac9091f" id="r_gada1ad2953a2b1f509933ae743ac9091f"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gada1ad2953a2b1f509933ae743ac9091f">getSafeMultiPortNodeDataPtr</a> (<a class="el" href="classhopsan_1_1Port.html">Port</a> *pPort, const size_t portIdx, const int dataId, const double defaultValue)</td></tr>
<tr class="memdesc:gada1ad2953a2b1f509933ae743ac9091f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to node data in a subport in a multiport (also setting initial value at the same time)  <br /></td></tr>
<tr class="separator:gada1ad2953a2b1f509933ae743ac9091f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0ee21ce93d05e31a493ec756a723270" id="r_gaf0ee21ce93d05e31a493ec756a723270"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf0ee21ce93d05e31a493ec756a723270">readNodeSafe</a> (const <a class="el" href="classhopsan_1_1HString.html">HString</a> &amp;rPortName, const <a class="el" href="classhopsan_1_1HString.html">HString</a> &amp;rDataName, const size_t subPortIdx=0)</td></tr>
<tr class="memdesc:gaf0ee21ce93d05e31a493ec756a723270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read value based on the port and node data name.  <br /></td></tr>
<tr class="separator:gaf0ee21ce93d05e31a493ec756a723270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f05a4418a697533a3b8608d9587988d" id="r_ga2f05a4418a697533a3b8608d9587988d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2f05a4418a697533a3b8608d9587988d">readNodeSafe</a> (const <a class="el" href="classhopsan_1_1HString.html">HString</a> &amp;rPortName, const size_t dataId, const size_t subPortIdx=0)</td></tr>
<tr class="memdesc:ga2f05a4418a697533a3b8608d9587988d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read value based on the port name and node data id.  <br /></td></tr>
<tr class="separator:ga2f05a4418a697533a3b8608d9587988d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3676dd9b0679031e7366a353872daae1" id="r_ga3676dd9b0679031e7366a353872daae1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3676dd9b0679031e7366a353872daae1">writeNodeSafe</a> (const <a class="el" href="classhopsan_1_1HString.html">HString</a> &amp;rPortName, const <a class="el" href="classhopsan_1_1HString.html">HString</a> &amp;rDataName, const double value, const size_t subPortIdx=0)</td></tr>
<tr class="memdesc:ga3676dd9b0679031e7366a353872daae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write node data based on port and data name.  <br /></td></tr>
<tr class="separator:ga3676dd9b0679031e7366a353872daae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84eb4c6cf5589b8b057cd5bcf049e6e3" id="r_ga84eb4c6cf5589b8b057cd5bcf049e6e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga84eb4c6cf5589b8b057cd5bcf049e6e3">writeNodeSafe</a> (const <a class="el" href="classhopsan_1_1HString.html">HString</a> &amp;rPortName, const size_t dataId, const double value, const size_t subPortIdx=0)</td></tr>
<tr class="memdesc:ga84eb4c6cf5589b8b057cd5bcf049e6e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write node data based on port and data id.  <br /></td></tr>
<tr class="separator:ga84eb4c6cf5589b8b057cd5bcf049e6e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b8a70bc8ae6f0c431efd91436761102" id="r_ga4b8a70bc8ae6f0c431efd91436761102"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4b8a70bc8ae6f0c431efd91436761102">readNodeSafe</a> (const size_t idx, const size_t subPortIdx=0) const</td></tr>
<tr class="memdesc:ga4b8a70bc8ae6f0c431efd91436761102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a value from the connected node.  <br /></td></tr>
<tr class="separator:ga4b8a70bc8ae6f0c431efd91436761102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga613c0e773bcef0a132696ff6f2990267" id="r_ga613c0e773bcef0a132696ff6f2990267"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga613c0e773bcef0a132696ff6f2990267">writeNodeSafe</a> (const size_t idx, const double value, const size_t subPortIdx=0)</td></tr>
<tr class="memdesc:ga613c0e773bcef0a132696ff6f2990267"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a value to the connected node.  <br /></td></tr>
<tr class="separator:ga613c0e773bcef0a132696ff6f2990267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe95214982a59a535a50bb8d8bd2b2ef" id="r_gafe95214982a59a535a50bb8d8bd2b2ef"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafe95214982a59a535a50bb8d8bd2b2ef">readNodeSafe</a> (const size_t idx, const size_t subPortIdx) const</td></tr>
<tr class="memdesc:gafe95214982a59a535a50bb8d8bd2b2ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a value from the connected node.  <br /></td></tr>
<tr class="separator:gafe95214982a59a535a50bb8d8bd2b2ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79d16b15254ca2e39181de4378d01db9" id="r_ga79d16b15254ca2e39181de4378d01db9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga79d16b15254ca2e39181de4378d01db9">writeNodeSafe</a> (const size_t idx, const double value, const size_t subPortIdx)</td></tr>
<tr class="memdesc:ga79d16b15254ca2e39181de4378d01db9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a value to the connected node.  <br /></td></tr>
<tr class="separator:ga79d16b15254ca2e39181de4378d01db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga32d626626eee0bc4ade146973f6abb1c" name="ga32d626626eee0bc4ade146973f6abb1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32d626626eee0bc4ade146973f6abb1c">&#9670;&#160;</a></span>finalize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void finalize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Optional function that is called after every simulation, can be used to clean up memory allocation made in initialize. </p>

<p>Reimplemented in <a class="el" href="classhopsan_1_1ComponentSystem.html#a32d626626eee0bc4ade146973f6abb1c">ComponentSystem</a>.</p>

</div>
</div>
<a id="gac6f63293b243b44a847868f34cb4abe2" name="gac6f63293b243b44a847868f34cb4abe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6f63293b243b44a847868f34cb4abe2">&#9670;&#160;</a></span>getSafeMultiPortNodeDataPtr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double * getSafeMultiPortNodeDataPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhopsan_1_1Port.html">Port</a> *</td>          <td class="paramname"><span class="paramname"><em>pPort</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>portIdx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>dataId</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to node data in a subport in a multiport. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pPort</td><td>A pointer to the port from which to fetch NodeData pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">portIdx</td><td>The index of the subport in a multiport </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataId</td><td>The enum id for the node value to fetch pointer to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the specified NodeData or a pointer to dummy NodeData </dd></dl>

</div>
</div>
<a id="gada1ad2953a2b1f509933ae743ac9091f" name="gada1ad2953a2b1f509933ae743ac9091f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada1ad2953a2b1f509933ae743ac9091f">&#9670;&#160;</a></span>getSafeMultiPortNodeDataPtr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double * getSafeMultiPortNodeDataPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhopsan_1_1Port.html">Port</a> *</td>          <td class="paramname"><span class="paramname"><em>pPort</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>portIdx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>dataId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>defaultValue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to node data in a subport in a multiport (also setting initial value at the same time) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pPort</td><td>A pointer to the port from which to fetch NodeData pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">portIdx</td><td>The index of the subport in a multiport </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataId</td><td>The enum id for the node value to fetch pointer to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultValue</td><td>The initial value to set for this node data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the specified NodeData or a pointer to dummy NodeData </dd></dl>

</div>
</div>
<a id="ga216152a14db9fbf42d51bc96359de445" name="ga216152a14db9fbf42d51bc96359de445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga216152a14db9fbf42d51bc96359de445">&#9670;&#160;</a></span>getSafeNodeDataPtr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double * getSafeNodeDataPtr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhopsan_1_1HString.html">HString</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rPortName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>dataId</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the node data variable, (<a class="el" href="classhopsan_1_1Port.html">Port</a> name version) </p>
<dl class="section note"><dt>Note</dt><dd>This function is slow, you should not run it during simulation</dd></dl>
<p>The safe in this version means that a dummy pointer will be returned if the desired one was not found, this prevents crash and the need to check that return pointer is ok, giving cleaner component code An error message is given if the desired data was not found </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rPortName</td><td>The name of the port from which to fetch the node data pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataId</td><td>The enum id for the node value to fetch pointer to, (Ex: ModeHydraulic::Pressure) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the specified NodeData or a pointer to dummy NodeData </dd></dl>

</div>
</div>
<a id="gaacbc55de899a64164d8deec608ed649e" name="gaacbc55de899a64164d8deec608ed649e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaacbc55de899a64164d8deec608ed649e">&#9670;&#160;</a></span>getSafeNodeDataPtr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double * getSafeNodeDataPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhopsan_1_1Port.html">Port</a> *</td>          <td class="paramname"><span class="paramname"><em>pPort</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>dataId</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the node data variable, (<a class="el" href="classhopsan_1_1Port.html">Port</a> pointer version) </p>
<dl class="section note"><dt>Note</dt><dd>This function is slow, you should not run it during simulation</dd></dl>
<p>The safe in this version means that a dummy pointer will be returned if the desired one was not found, this prevents crash and the need to check that return pointer is ok, giving cleaner component code An error message is given if the desired data was not found </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pPort</td><td>A pointer to the port from which to fetch the node data pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataId</td><td>The enum id for the node value to fetch pointer to, (Ex: ModeHydraulic::Pressure) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the specified NodeData or a pointer to dummy NodeData </dd></dl>

</div>
</div>
<a id="ga25a40b6614565f755233080a384c35f1" name="ga25a40b6614565f755233080a384c35f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25a40b6614565f755233080a384c35f1">&#9670;&#160;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void initialize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The initialize function must be overloaded in each component, it is used to initialize the component just before simulation begins. </p>
<p>In this function you should get node data ptrs and calculate initial values to write to the nodes You are not allowed to reconnect internal connections in this function, as other components may already have initialized and fetch data pointers to ports/nodes in this component </p>

<p>Reimplemented in <a class="el" href="classhopsan_1_1DummyComponent.html#a25a40b6614565f755233080a384c35f1">DummyComponent</a>.</p>

</div>
</div>
<a id="gab4160d172bac363b50a6a0123d18f128" name="gab4160d172bac363b50a6a0123d18f128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4160d172bac363b50a6a0123d18f128">&#9670;&#160;</a></span>readNode() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double readNode </td>
          <td>(</td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>subPortIdx</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a value from the connected node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>The data id of the data to read </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subPortIdx</td><td>The subPort to read from (range is NOT checked) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The data value </dd></dl>

<p>Reimplemented from <a class="el" href="#ga069fa4111f0bd1baf83b86c9a766c00f">Port</a>.</p>

</div>
</div>
<a id="ga42bf72b453e0208c678b2c34bb0dcb40" name="ga42bf72b453e0208c678b2c34bb0dcb40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42bf72b453e0208c678b2c34bb0dcb40">&#9670;&#160;</a></span>readNode() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double readNode </td>
          <td>(</td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a value from the connected node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>The data id of the data to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The data value </dd></dl>

</div>
</div>
<a id="ga069fa4111f0bd1baf83b86c9a766c00f" name="ga069fa4111f0bd1baf83b86c9a766c00f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga069fa4111f0bd1baf83b86c9a766c00f">&#9670;&#160;</a></span>readNode() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double readNode </td>
          <td>(</td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>subPortIdx</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a value from the connected node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>The data id of the data to read </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subPortIdx</td><td>(Ignored on non multi ports) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The data value </dd></dl>

<p>Reimplemented in <a class="el" href="#gab4160d172bac363b50a6a0123d18f128">MultiPort</a>.</p>

</div>
</div>
<a id="gaf0ee21ce93d05e31a493ec756a723270" name="gaf0ee21ce93d05e31a493ec756a723270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0ee21ce93d05e31a493ec756a723270">&#9670;&#160;</a></span>readNodeSafe() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double readNodeSafe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhopsan_1_1HString.html">HString</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rPortName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhopsan_1_1HString.html">HString</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rDataName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>subPortIdx</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read value based on the port and node data name. </p>
<dl class="section note"><dt>Note</dt><dd>This functions is slow but safe, do not use it during simulation</dd></dl>
<p>It searches for data based on strings, this make it unsuitable for use during simulation but it is suitable during initialize when port pointers are not desired/available This function will also check so that the desired data actually exist in the requested node, error message will be sent if it does not</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rPortName</td><td>The port to write data to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rDataName</td><td>The data variable name for the data to be written </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subPortIdx</td><td>The index of a multiport subport </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value from the requested PortName#DataName or -1 if failure, Note! an error message will also be shown </dd></dl>

</div>
</div>
<a id="ga2f05a4418a697533a3b8608d9587988d" name="ga2f05a4418a697533a3b8608d9587988d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f05a4418a697533a3b8608d9587988d">&#9670;&#160;</a></span>readNodeSafe() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double readNodeSafe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhopsan_1_1HString.html">HString</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rPortName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>dataId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>subPortIdx</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read value based on the port name and node data id. </p>
<dl class="section note"><dt>Note</dt><dd>This functions is slow but safe, do not use it during simulation</dd></dl>
<p>It searches for data based on strings, this make it unsuitable for use during simulation but it is suitable during initialize when port pointers are not desired/available This function will only check if node data id is within range in the node, not if the data actually exist</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rPortName</td><td>The port to write data to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataId</td><td>The data variable id for the data to be written </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subPortIdx</td><td>The index of a multiport subport </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value from the requested PortName#DataId or -1 if failure, Note! an error message will also be shown </dd></dl>

</div>
</div>
<a id="gafe95214982a59a535a50bb8d8bd2b2ef" name="gafe95214982a59a535a50bb8d8bd2b2ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe95214982a59a535a50bb8d8bd2b2ef">&#9670;&#160;</a></span>readNodeSafe() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double readNodeSafe </td>
          <td>(</td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>subPortIdx</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a value from the connected node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>The data id of the data to read </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subPortIdx</td><td>The subPort index in the multi port</td></tr>
  </table>
  </dd>
</dl>
<p>Safe but slow version, will not crash if idx out of bounds </p><dl class="section return"><dt>Returns</dt><dd>The data value or -1 if any of the idxes are out of range </dd></dl>

<p>Reimplemented from <a class="el" href="#ga4b8a70bc8ae6f0c431efd91436761102">Port</a>.</p>

</div>
</div>
<a id="ga4b8a70bc8ae6f0c431efd91436761102" name="ga4b8a70bc8ae6f0c431efd91436761102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b8a70bc8ae6f0c431efd91436761102">&#9670;&#160;</a></span>readNodeSafe() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double readNodeSafe </td>
          <td>(</td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>subPortIdx</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a value from the connected node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>The data id of the data to read </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subPortIdx</td><td>The subPort index of a port in a multiport, (ignored if not a multiport)</td></tr>
  </table>
  </dd>
</dl>
<p>Safe but slow version, will not crash if idx out of bounds </p><dl class="section return"><dt>Returns</dt><dd>The data value </dd></dl>

<p>Reimplemented in <a class="el" href="#gafe95214982a59a535a50bb8d8bd2b2ef">MultiPort</a>.</p>

</div>
</div>
<a id="gaa63c51fa3173cbaf9d5352ed24f5f706" name="gaa63c51fa3173cbaf9d5352ed24f5f706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa63c51fa3173cbaf9d5352ed24f5f706">&#9670;&#160;</a></span>simulateOneTimestep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simulateOneTimestep </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simulates one time step. This component must be overloaded en each component. </p>
<p>This is the function where all the component model equations should be written. This function is called once for every time step </p>

<p>Reimplemented in <a class="el" href="classhopsan_1_1DummyComponent.html#aa63c51fa3173cbaf9d5352ed24f5f706">DummyComponent</a>.</p>

</div>
</div>
<a id="gacbbc53679a2e6738e4a1a9a35d654128" name="gacbbc53679a2e6738e4a1a9a35d654128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbbc53679a2e6738e4a1a9a35d654128">&#9670;&#160;</a></span>stopSimulation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stopSimulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhopsan_1_1HString.html">HString</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rReason</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Terminate/stop a running initialization or simulation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rReason</td><td>An optional <a class="el" href="classhopsan_1_1HString.html">HString</a> describing the reason for the stop</td></tr>
  </table>
  </dd>
</dl>
<p>Typically used inside components simulateOneTimestep method </p>

</div>
</div>
<a id="gac478c4f77b1aa1dcc7201693d80f128f" name="gac478c4f77b1aa1dcc7201693d80f128f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac478c4f77b1aa1dcc7201693d80f128f">&#9670;&#160;</a></span>writeNode() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void writeNode </td>
          <td>(</td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>subPortIdx</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a value to the connected node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>The data id of the data to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subPortIdx</td><td>The subPort to write to (range is NOT checked) </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="#ga89bcd188cf935b03ccdc26e5170ab3bc">Port</a>.</p>

</div>
</div>
<a id="ga3e3cf2c419e0f82cba4e8881be0986e1" name="ga3e3cf2c419e0f82cba4e8881be0986e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e3cf2c419e0f82cba4e8881be0986e1">&#9670;&#160;</a></span>writeNode() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void writeNode </td>
          <td>(</td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a value to the connected node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>The data id of the data to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga89bcd188cf935b03ccdc26e5170ab3bc" name="ga89bcd188cf935b03ccdc26e5170ab3bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89bcd188cf935b03ccdc26e5170ab3bc">&#9670;&#160;</a></span>writeNode() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void writeNode </td>
          <td>(</td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>subPortIdx</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a value to the connected node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>The data id of the data to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subPortIdx</td><td>(Ignored on non multi ports) </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="#gac478c4f77b1aa1dcc7201693d80f128f">MultiPort</a>.</p>

</div>
</div>
<a id="ga3676dd9b0679031e7366a353872daae1" name="ga3676dd9b0679031e7366a353872daae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3676dd9b0679031e7366a353872daae1">&#9670;&#160;</a></span>writeNodeSafe() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void writeNodeSafe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhopsan_1_1HString.html">HString</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rPortName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhopsan_1_1HString.html">HString</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rDataName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>subPortIdx</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write node data based on port and data name. </p>
<dl class="section note"><dt>Note</dt><dd>This functions is slow but safe, do not use it during simulation</dd></dl>
<p>It searches for data based on strings, this make it unsuitable for use during simulation but it is suitable during initialize when port pointers are not desired/available This function will also check so that the desired data actually exist in the requested node, error message will be sent if it does not</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rPortName</td><td>The port to write data to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rDataName</td><td>The data variable name for the data to be written </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subPortIdx</td><td>The index of a multiport subport </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga84eb4c6cf5589b8b057cd5bcf049e6e3" name="ga84eb4c6cf5589b8b057cd5bcf049e6e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84eb4c6cf5589b8b057cd5bcf049e6e3">&#9670;&#160;</a></span>writeNodeSafe() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void writeNodeSafe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhopsan_1_1HString.html">HString</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rPortName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>dataId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>subPortIdx</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write node data based on port and data id. </p>
<dl class="section note"><dt>Note</dt><dd>This functions is slow but safe, do not use it during simulation</dd></dl>
<p>It searches for data based on strings, this make it unsuitable for use during simulation but it is suitable during initialize when port pointers are not desired/available This function will only check if node data id is within range in the node, not if the data actually exist</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rPortName</td><td>The port to write data to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataId</td><td>The data variable id for the data to be written </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subPortIdx</td><td>The index of a multiport subport </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga79d16b15254ca2e39181de4378d01db9" name="ga79d16b15254ca2e39181de4378d01db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79d16b15254ca2e39181de4378d01db9">&#9670;&#160;</a></span>writeNodeSafe() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void writeNodeSafe </td>
          <td>(</td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>subPortIdx</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a value to the connected node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>The data id of the data to write (Such as NodeHydraulic::Pressure) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value of the data to read </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subPortIdx</td><td>The subport to write to, (range check is performed)</td></tr>
  </table>
  </dd>
</dl>
<p>Safe but slow version, will not crash if idx out of bounds </p>

<p>Reimplemented from <a class="el" href="#ga613c0e773bcef0a132696ff6f2990267">Port</a>.</p>

</div>
</div>
<a id="ga613c0e773bcef0a132696ff6f2990267" name="ga613c0e773bcef0a132696ff6f2990267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga613c0e773bcef0a132696ff6f2990267">&#9670;&#160;</a></span>writeNodeSafe() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void writeNodeSafe </td>
          <td>(</td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>subPortIdx</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a value to the connected node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>The data id of the data to write (Such as NodeHydraulic::Pressure) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value of the data to read </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subPortIdx</td><td>Ignored for non multi ports</td></tr>
  </table>
  </dd>
</dl>
<p>Safe but slow version, will not crash if idx out of bounds </p>

<p>Reimplemented in <a class="el" href="#ga79d16b15254ca2e39181de4378d01db9">MultiPort</a>, and <a class="el" href="classhopsan_1_1ReadPort.html#a613c0e773bcef0a132696ff6f2990267">ReadPort</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Oct 11 2024 15:47:49 for Hopsan by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
