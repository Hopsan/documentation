<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Hopsan: Writing The Actual Component Code</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="hopsan.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Hopsan
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('devWritingCppComponentsPageTheComponentPage.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">Writing The Actual Component Code</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Components are written in header-only C++ files (.hpp). In this section we will look at "MyExampleConstantOrifice.hpp" from the exampleComponentLibrary. This is a very simple component that only includes a subset of functions. This is convenient when "getting started" but you should also see <a class="el" href="group__ComponentAuthorFunctions.html">ComponentAuthorFunctions</a> for a list of all functions that can be useful when creating components.<br  />
 </p>
<h1><a class="anchor" id="_stepbystepexampleorifice"></a>
Step by Step, MyExampleConstantOrifice.hpp</h1>
<p>This part goes through the basic structure of the component file. You should look in the actual file for the full code and more detailed comments. You should also have a look at the <code>MyExampleOrifice.hpp</code> file. The difference between the files illustrate the difference between having a constant parameter or a variable parameter. (Input Variable).<br  />
 </p>
<h2><a class="anchor" id="_firstpart"></a>
Include Directives and Header Guard</h2>
 <div class="fragment"><div class="line">        http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div>
<div class="line"> </div>
<div class="line">    Unless required by applicable law or agreed to in writing, software</div>
<div class="line">    distributed under the License is distributed on an <span class="stringliteral">&quot;AS IS&quot;</span> BASIS,</div>
<div class="line">    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</div>
<div class="line">    See the License <span class="keywordflow">for</span> the specific language governing permissions and</div>
<div class="line">    limitations under the License.</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> The full license is available in the file LICENSE.</div>
<div class="line"> For details about the <span class="stringliteral">&#39;Hopsan Group&#39;</span> or information about Authors and</div>
<div class="line"> Contributors see the HOPSANGROUP and AUTHORS files that are located in</div>
<div class="line"> the Hopsan source code root directory.</div>
<div class="line"> </div>
<div class="line">-----------------------------------------------------------------------------*/</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Header guard to avoid inclusion of the same code twice</span></div>
<div class="line"><span class="comment">// Every hpp file in your library need to have its own UNIQUE header guard</span></div>
<div class="line"><span class="preprocessor">#ifndef MYEXAMPLECONSTANTORIFICE_H</span></div>
<div class="line"><span class="preprocessor">#define MYEXAMPLECONSTANTORIFICE_H</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Include the necessary header files from Hopsan</span></div>
<div class="line"><span class="preprocessor">#include &quot;ComponentEssentials.h&quot;</span></div>
</div><!-- fragment --><p>This first lines set a header guard to avoid including the same code twice. Technically you do not need the header guards if you can guarantee that you do not include the same file twice (usually not a problem in component libraries). Then we include the essential functions for the component from the HopsanCore. It may be necessary to include more files, for example "ComponentUtilities.h" for accessing built-in component utilities in Hopsan. You may also include other external header files if you wish to include function from other external libraries.</p>
<h2><a class="anchor" id="_classdecl"></a>
Class Declaration and Component CQS Type Selection</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyExampleConstantOrifice : <span class="keyword">public</span> ComponentQ</div>
</div><!-- fragment --><p>Next the component class is declared. We inherit from a <b><a class="el" href="classhopsan_1_1ComponentQ.html">ComponentQ</a></b> as this is a Q-type component. This could also be <b><a class="el" href="classhopsan_1_1ComponentC.html">ComponentC</a></b> or <b><a class="el" href="classhopsan_1_1ComponentSignal.html">ComponentSignal</a></b> for C-type, Signal-type components. It is also possible to inherit <b><a class="el" href="classhopsan_1_1ComponentSystem.html">ComponentSystem</a></b> in order to write programmed subsystems. But this is <b>VERY</b> advanced and complicated and will not be covered in the documentation.</p>
<h2><a class="anchor" id="_private"></a>
Private Class Members</h2>
<div class="fragment"><div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// Private member variables</span></div>
<div class="line">    <span class="keywordtype">double</span> mKc;</div>
<div class="line">    Port *mpP1, *mpP2;</div>
</div><!-- fragment --><p>First the <b>private</b> part of the component is specified. Here we declare member variables, (variables that should be persistent in the component). In this case we have a restriction coefficient called <b>mKc</b> and two port pointers called <b>mpP1</b> and <b>mpP2</b> ("m" is an abbreviation of "member" and "mp" means "member and pointer"). The names do not actually matter, but using a naming convention makes the code easier to read.</p>
<h2><a class="anchor" id="_public"></a>
Public Class Members</h2>
<div class="fragment"><div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// The creator function that is registered when a component lib is loaded into Hopsan</span></div>
<div class="line">    <span class="comment">// This static function is mandatory</span></div>
<div class="line">    <span class="keyword">static</span> Component *Creator()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">new</span> MyExampleConstantOrifice();</div>
<div class="line">    }</div>
</div><!-- fragment --><p>In the <b>public</b> part we first define a static creator function, which is used to create instances of the component in the simulation core. Nothing needs to be changed except the name of the class.</p>
<h2><a class="anchor" id="_configure"></a>
configure()</h2>
<div class="fragment"><div class="line">    <span class="keywordtype">void</span> configure()</div>
<div class="line">    {</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Add ports to the component</span></div>
<div class="line">        mpP1 = addPowerPort(<span class="stringliteral">&quot;P1&quot;</span>, <span class="stringliteral">&quot;NodeHydraulic&quot;</span>, <span class="stringliteral">&quot;Port 1&quot;</span>);</div>
<div class="line">        mpP2 = addPowerPort(<span class="stringliteral">&quot;P2&quot;</span>, <span class="stringliteral">&quot;NodeHydraulic&quot;</span>, <span class="stringliteral">&quot;Port 2&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Add constant</span></div>
<div class="line">        addConstant(<span class="stringliteral">&quot;Kc&quot;</span>, <span class="stringliteral">&quot;Pressure-Flow Coefficient&quot;</span>, <span class="stringliteral">&quot;[m^5/Ns]&quot;</span>, 1.0e-11, mKc);</div>
<div class="line">    }</div>
</div><!-- fragment --><p>The second member function you need to define is the <b>configure</b> function for the component. This function is run every time a new object of the class is created (added to the model). The function is used to register ports, input variables, output variables and constants, and to configure default values for member variables. First we create the ports used for communication with the surrounding components, in this case two hydraulic PowerPorts. Finally, we register the restrictor coefficient as constant parameter with a name, description and unit. This will make it available to the user in the graphical interface.</p>
<p><b>Adding Ports:</b> The following functions are available for port creation: You need to specify a unique (within the component) <em>portname</em>, which <em>nodetype</em> it should use, and whether it must be connected: <em>Port::Required</em> or <em>Port::NotRequired</em>. If the final argument is omitted it will default to Port::Required. <em>Description</em> is optional (but recommended) The currently available built-in node types can be found here: <a class="el" href="group__Nodes.html">NodeTypes</a><br  />
New node types can be added through external libraries, but this should be avoided if possible. </p><div class="fragment"><div class="line">Port* addPowerPort(<span class="keyword">const</span> HString &amp;rPortName, <span class="keyword">const</span> HString &amp;rNodeType, <span class="keyword">const</span> HString &amp;rDescription, <span class="keyword">const</span> <a class="code hl_enumeration" href="classhopsan_1_1Port.html#ad10d25321eed89c75e335fc0d9c7e361">Port::RequireConnectionEnumT</a> reqConnect=Port::Required);</div>
<div class="line">Port* addReadPort(<span class="keyword">const</span> HString &amp;rPortName, <span class="keyword">const</span> HString &amp;rNodeType, <span class="keyword">const</span> HString &amp;rDescription, <span class="keyword">const</span> <a class="code hl_enumeration" href="classhopsan_1_1Port.html#ad10d25321eed89c75e335fc0d9c7e361">Port::RequireConnectionEnumT</a> reqConnect=Port::Required);</div>
<div class="line">Port* addPowerMultiPort(<span class="keyword">const</span> HString &amp;rPortName, <span class="keyword">const</span> HString &amp;rNodeType, <span class="keyword">const</span> HString &amp;rDescription, <span class="keyword">const</span> <a class="code hl_enumeration" href="classhopsan_1_1Port.html#ad10d25321eed89c75e335fc0d9c7e361">Port::RequireConnectionEnumT</a> reqConnect=Port::Required);</div>
<div class="line">Port* addReadMultiPort(<span class="keyword">const</span> HString &amp;rPortName, <span class="keyword">const</span> HString &amp;rNodeType, <span class="keyword">const</span> HString &amp;rDescription, <span class="keyword">const</span> <a class="code hl_enumeration" href="classhopsan_1_1Port.html#ad10d25321eed89c75e335fc0d9c7e361">Port::RequireConnectionEnumT</a> reqConnect=Port::Required);</div>
<div class="line">Port* addWritePort(<span class="keyword">const</span> HString &amp;rPortName, <span class="keyword">const</span> HString &amp;rNodeType, <span class="keyword">const</span> HString &amp;rDescription, <span class="keyword">const</span> <a class="code hl_enumeration" href="classhopsan_1_1Port.html#ad10d25321eed89c75e335fc0d9c7e361">Port::RequireConnectionEnumT</a> reqConnect=Port::Required);</div>
<div class="ttc" id="aclasshopsan_1_1Port_html_ad10d25321eed89c75e335fc0d9c7e361"><div class="ttname"><a href="classhopsan_1_1Port.html#ad10d25321eed89c75e335fc0d9c7e361">hopsan::Port::RequireConnectionEnumT</a></div><div class="ttdeci">RequireConnectionEnumT</div><div class="ttdoc">This enum specifies the RequiredConnection enums.</div><div class="ttdef"><b>Definition</b> Port.h:65</div></div>
</div><!-- fragment --><p><b>Adding Input and Output Variables:</b> The following functions are available for input and output variable creation: If the last argument <em>ppNodeData</em> is given it will auto register and set the data pointer so that you can use it safely without having to worry about it dangling. In the output variable case, the <em>defaultValue</em> is optional. If a default vale is not given, then the output value will not get a start value. This is usefully in cases where the component should calculate its own initial values. Example: In a Sum component you want the initial output value to be the sum of the initial input values. Being able to set a different start value on the output does not make sense. </p><div class="fragment"><div class="line">Port *addInputVariable(<span class="keyword">const</span> HString &amp;rName, <span class="keyword">const</span> HString &amp;rDescription, <span class="keyword">const</span> HString &amp;rUnit, <span class="keyword">const</span> <span class="keywordtype">double</span> defaultValue, <span class="keywordtype">double</span> **ppNodeData=0);</div>
<div class="line">Port *addOutputVariable(<span class="keyword">const</span> HString &amp;rName, <span class="keyword">const</span> HString &amp;rDescription, <span class="keyword">const</span> HString &amp;rUnit, <span class="keywordtype">double</span> **ppNodeData=0);</div>
<div class="line">Port *addOutputVariable(<span class="keyword">const</span> HString &amp;rName, <span class="keyword">const</span> HString &amp;rDescription, <span class="keyword">const</span> HString &amp;rUnit, <span class="keyword">const</span> <span class="keywordtype">double</span> defaultValue, <span class="keywordtype">double</span> **ppNodeData=0);</div>
</div><!-- fragment --><p><b>Adding Constants:</b> The following functions are available for creating constants The correct function will automatically be selected depending on the rData type. The function will register the given name, unit and description and connect this information to a pointer pointing at the variable you specify as the <b>rData</b> argument. The conditional Constant associates description strings to integer numbers and is shown as a drop-down selection box in the HopsanGUI. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> addConstant(<span class="keyword">const</span> HString &amp;rName, <span class="keyword">const</span> HString &amp;rDescription, <span class="keyword">const</span> HString &amp;rUnit, <span class="keyword">const</span> <span class="keywordtype">double</span> defaultValue, <span class="keywordtype">double</span> &amp;rData);</div>
<div class="line"><span class="keywordtype">void</span> addConstant(<span class="keyword">const</span> HString &amp;rName, <span class="keyword">const</span> HString &amp;rDescription, <span class="keyword">const</span> HString &amp;rUnit, <span class="keyword">const</span> <span class="keywordtype">int</span> defaultValue, <span class="keywordtype">int</span> &amp;rData);</div>
<div class="line"><span class="keywordtype">void</span> addConstant(<span class="keyword">const</span> HString &amp;rName, <span class="keyword">const</span> HString &amp;rDescription, <span class="keyword">const</span> HString &amp;rUnit, <span class="keyword">const</span> HString &amp;defaultValue, HString &amp;rData);</div>
<div class="line"><span class="keywordtype">void</span> addConstant(<span class="keyword">const</span> HString &amp;rName, <span class="keyword">const</span> HString &amp;rDescription, <span class="keyword">const</span> HString &amp;rUnit, <span class="keyword">const</span> <span class="keywordtype">bool</span> defaultValue, <span class="keywordtype">bool</span> &amp;rData);</div>
<div class="line"><span class="keywordtype">void</span> addConditionalConstant(<span class="keyword">const</span> HString &amp;rName, <span class="keyword">const</span> HString &amp;rDescription, std::vector&lt;HString&gt; &amp;rConditions, <span class="keywordtype">int</span> &amp;rData);</div>
</div><!-- fragment --><h2><a class="anchor" id="_initialize"></a>
initialize()</h2>
<div class="fragment"><div class="line">    <span class="keywordtype">void</span> initialize()</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Nothing to initialize</span></div>
<div class="line">    }</div>
</div><!-- fragment --><p>The next member function that must be defined is the <b>initialize</b> function. This function is run once before simulation starts. This function runs after connections have been established, you can read or write to/from connected components. If needed, you can use this information to initialize your component properly. This is also the place to allocate additional memory if needed. In this function you also typically initialize more advanced utilities such as (but not limited to) Delays, Integrators or Transfer-functions. In this example case we have nothing that needs to be initialized.</p>
<h2><a class="anchor" id="_simulateOneTimestep"></a>
simulateOneTimestep()</h2>
<div class="fragment"><div class="line">    <span class="keywordtype">void</span> simulateOneTimestep()</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//Get variable values from nodes</span></div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> c1 = mpP1-&gt;readNode(NodeHydraulic::WaveVariable);</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> Zc1 = mpP1-&gt;readNode(NodeHydraulic::CharImpedance);</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> c2 = mpP2-&gt;readNode(NodeHydraulic::WaveVariable);</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> Zc2 = mpP2-&gt;readNode(NodeHydraulic::CharImpedance);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">//Orifice equations</span></div>
<div class="line">        <span class="keywordtype">double</span> q2 = mKc*(c1-c2)/(1.0+mKc*(Zc1+Zc2));</div>
<div class="line">        <span class="keywordtype">double</span> q1 = -q2;</div>
<div class="line">        <span class="keywordtype">double</span> p1 = c1 + q1*Zc1;</div>
<div class="line">        <span class="keywordtype">double</span> p2 = c2 + q2*Zc2;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">//Write new values to nodes</span></div>
<div class="line">        mpP1-&gt;writeNode(NodeHydraulic::Pressure, p1);</div>
<div class="line">        mpP1-&gt;writeNode(NodeHydraulic::Flow, q1);</div>
<div class="line">        mpP2-&gt;writeNode(NodeHydraulic::Pressure, p2);</div>
<div class="line">        mpP2-&gt;writeNode(NodeHydraulic::Flow, q2);</div>
<div class="line">    }</div>
</div><!-- fragment --><p>The next function <b>simulateOneTimestep</b>, is the most important member function. It contains the model equations that are executed each time step. We begin by creating local variables with copies of the values from the connected ports, this is intended to make the actual equations more human readable. If you know that one of these local variables will not change, then you should make it <em>const</em>. This will prevent you from accidentally assigning it and may allow the compiler to optimize the code better. The middle part consists of the actual equations. In this case we calculate flow and pressure through the orifice from wave variables and impedance in the neighboring C-type components. We end by writing back the new values that were calculated.</p>
<h2><a class="anchor" id="_finalize"></a>
finalize()</h2>
<div class="fragment"><div class="line">    <span class="keywordtype">void</span> finalize()</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Nothing to finalize</span></div>
<div class="line">    }</div>
</div><!-- fragment --><p>The next member function <b>finalize</b>, is optional. It is only useful if you want some code to be run after simulation has finished. This is usually only needed if you want to free memory that was additionally allocated in the <em>initialize</em> function.</p>
<h2><a class="anchor" id="_deconfigure"></a>
deconfigure()</h2>
<div class="fragment"><div class="line">    <span class="keywordtype">void</span> deconfigure()</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Nothing to deconfigure</span></div>
<div class="line">    }</div>
</div><!-- fragment --><p>The last member function <b>deconfigure</b>, is also optional. This code is run once the component is deleted. Here you can cleanup any custom memory allocation or similar that you have don in the configure function. <em>Note!</em> You do not need to remove ports, constants or variables. Hopsan will handle that automatically. Usually you never need to implement anything in this function. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Sep 27 2024 15:37:52 for Hopsan by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
